package ArmySpawner

// Standard libs imports:
import LinkedList
import Lodash
import HashMap

// Local imports:
import ScoreBoard
import GameConstants

// Distance between units positioned in formation mode
@configurable constant FORMATION_WIDTH = 120.
@configurable constant FORMATION_HEIGHT = 80.

// Max number of unit per line
@configurable constant UNIT_PER_LINE = 4

@configurable constant UNIT_CAP = 80

interface LastArmyRemaining
    abstract function execute()

public LastArmyRemaining onLastArmyRemaining

interface AllUnitDead
    abstract function execute(player winner)

public AllUnitDead onAllUnitDead



class SpawnZone
    rect spawnRect
    angle angle
    vec2 initialPos
    real width
    real height

    construct(rect spawnRect, vec2 initialPos, angle angle)
        this.spawnRect = spawnRect
        this.angle = angle
        this.initialPos = initialPos
        this.width = spawnRect.width()
        this.height = spawnRect.height()

public let spawnZones = new LinkedList<SpawnZone>()
    ..add(new SpawnZone(gg_rct_Frontrank_SW, gg_rct_Frontrank_SW.getRightBot(), 0..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_SE, gg_rct_Frontrank_SE.getLeftBot(), 180..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_NW, gg_rct_Frontrank_NW.getRightBot(), 0..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_NE, gg_rct_Frontrank_NE.getLeftBot(), 180..asAngleDegrees()))

    ..add(new SpawnZone(gg_rct_Frontrank_ES, gg_rct_Frontrank_ES.getLeftTop(), 90..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_EN, gg_rct_Frontrank_EN.getLeftBot(), 270..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_WS, gg_rct_Frontrank_WS.getLeftTop(), 90..asAngleDegrees()))
    ..add(new SpawnZone(gg_rct_Frontrank_WN, gg_rct_Frontrank_WN.getLeftBot(), 270..asAngleDegrees()))

// TODO: Move to  round
public LinkedList<player> roundParticipant = new LinkedList<player>

public function spawnArmy(SpawnZone spawnZone, LinkedList<LinkedList<int>> army, player p)
    let spawnDirection = (spawnZone.angle.cos() == 0 ? 0 : 90).asAngleDegrees()

    int unitPerLine
    if spawnDirection.degrees() == 0.
        unitPerLine = (spawnZone.width / FORMATION_WIDTH).round()
    else
        unitPerLine = (spawnZone.height / FORMATION_WIDTH).round()

    var pos = spawnZone.initialPos
    let unitPerColumn = (80 / unitPerLine).floor()
    // TODO: adjust width computing for vertical rect

    let pData = pDatas.get(p)

    if roundParticipant.has(p) == false
        roundParticipant.add(p)

    var idx = 0
    for subArmy in army
        for unitId in subArmy

            let newUnit = createUnit(p, unitId, pos, spawnZone.angle)..pause()
            pData.spawnedUnits.add(newUnit)

            let armyPoints = newUnit.getPointValue()
            pData.addArmyPoints(armyPoints)
            scoreBoardEntries.get("ArmyPoints").addValue(p, armyPoints)
            pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)

            // Move to next line
            if (idx + 1) % unitPerLine == 0
                pos = spawnZone.initialPos.polarOffset(spawnZone.angle.op_minus(180..asAngleDegrees()), FORMATION_HEIGHT * idx / unitPerLine)
            idx++
            if (idx + 1) / unitPerLine > unitPerColumn
                break

    // let soldierIds = army.flatten()
    // int counter = 0
    // while soldierIds.size() > 0 and counter < UNIT_CAP
    //     let u = createUnit(p, soldierIds.dequeue(), pos, spawnZone.angle)
    //     u.pause()
    //     let armyPoints = u.getPointValue()
    //     pData.get(p).addArmyPoints(armyPoints)
    //     scoreBoardEntries.get("ArmyPoints").addValue(p, armyPoints)
    //     pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)
    //     // Move to next line
    //     if (counter + 1) % unitPerLine == 0
    //         pos = spawnZone.initialPos.polarOffset(spawnZone.angle.op_minus(180..asAngleDegrees()), FORMATION_HEIGHT * counter / unitPerLine)
    //     counter++

public function initUnitTrigger()
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
    ..addCondition(Condition(() -> GetDyingUnit().getPointValue() > 0))
    ..addAction() ->
        let killer = EventData.getKillingUnit().getOwner()
        let dying = EventData.getDyingUnit()

        let dyingOwner = dying.getOwner()

        let pData = pDatas.get(dying.getOwner())
        // Add blood points bounty
        if killer != ALTAR_PLAYER
            pDatas.get(killer).addBounty(dying.getPointValue())

        if pData.spawnedUnits.has(dying) == true
            pData.spawnedUnits.remove(dying)

        if pData.spawnedUnits.isEmpty()
            roundParticipant.remove(dyingOwner)

            Log.info("Removed " + dyingOwner.getName())

            if roundParticipant.size() == 1
                onLastArmyRemaining.execute()
            if roundParticipant.isEmpty()
                onAllUnitDead.execute(dyingOwner)
