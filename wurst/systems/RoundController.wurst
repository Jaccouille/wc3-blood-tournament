package RoundController

// Standard libs imports:
import ClosureForGroups
import ClosureTimers
import TimerUtils

// Local imports:
import SoldierEntity
import public Round
import AltarEntity
import ArmySpawner

public constant roundController = new RoundController()

constant SPAWN_TIME = 5.

interface OnAllroundsFinished
    abstract function execute()

public OnAllroundsFinished onAllroundsFinished

class RoundController
    int roundCount = 1
    constant rounds = new LinkedList<Round>

    Round currentround = null

    function addrounds(LinkedList<Round> rounds)
        this.rounds.addAll(rounds.copy())

    function roundSpawn()
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            // u.pause()
        if rounds.isEmpty()
            onAllroundsFinished.execute()
            return

        let tim = getTimer()
        // TODO: cleanup
        // let tdialog = tim.createTimerDialog()
        // ..setTitle("Time until next round:")
        // ..display(true)
        tim.doAfter(SPAWN_TIME) ->
            Log.info("Round " + roundCount.toString())
            roundCount++
            // tdialog.destr()

            currentround = rounds.dequeue()
            currentround.start()

    function checkIfCurrentroundDone(player winner)
        if currentround != null
            currentround.finish(winner)
            currentround = null
            roundSpawn()

public function initRoundController()
    roundController.addrounds(asList(
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7))
        ))

    doAfter(2) ->
        roundController.roundSpawn()

    onRoundStart() (Round round) ->
        Log.info("Round start")
        pDatas.forEach() (player key, PlayerData value) ->
            pDatas.get(key).armyPoints = 0

    onLastArmyRemaining = () ->
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            u.unpause()
        Log.info("Clean up phase")
        altarEntity.showCounter()

    onAllUnitDead = (player winner) ->
        Log.info("All unit dead")
        roundController.checkIfCurrentroundDone(winner)
        altarEntity.hideCounter()

    onAllroundsFinished = () ->
        Log.info("Match over")

    onRoundFinish() (Round round) ->
        Log.info("Round finish")
        doAfter(3) ->
            let winner = round.winner
            printTimed(winner.getName() + " gets " + altarEntity.bloodPointCounter.toString() + " for winning the round" , 15)
            forUnitsAll() (unit u) ->
                if IsUnitDeadBJ(u)
                    u.remove()
        doAfter(5) ->
            if round.goldReward > 0
                printTimed("You get " + round.goldReward.toString() + " golds from round income", 15)
            if round.bloodPointReward > 0
                printTimed("You get " + round.bloodPointReward.toString() + " blood points from round income", 15)
            pDatas.forEach() (player key, PlayerData value) ->
                value.giveReward()
                key.addGold(round.goldReward)
                key.addLumber(round.bloodPointReward)
