package RoundController

// Standard libs imports:
import ClosureForGroups
import ClosureTimers
import TimerUtils

// Local imports:
import OrderBlocker
import public Round
import AltarEntity
import SpawnZone

public constant roundController = new RoundController()

constant SPAWN_TIME = 5.

interface OnAllroundsFinished
    abstract function execute()

public OnAllroundsFinished onAllroundsFinished

class RoundController
    int roundCount = 1
    constant rounds = new LinkedList<Round>

    Round currentround = null

    function addrounds(LinkedList<Round> rounds)
        this.rounds.addAll(rounds.copy())

    function roundSpawn()
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            u.pause()
        if rounds.isEmpty()
            onAllroundsFinished.execute()
            return

        let tim = getTimer()
        // TODO: cleanup
        // let tdialog = tim.createTimerDialog()
        // ..setTitle("Time until next round:")
        // ..display(true)
        tim.doAfter(SPAWN_TIME) ->
            Log.info("Round " + roundCount.toString())
            roundCount++
            // tdialog.destr()

            currentround = rounds.dequeue()
            currentround.start()

    function checkIfCurrentroundDone(player winner)
        if currentround != null
            currentround.finish(winner)
            currentround = null
            roundSpawn()

public function initRoundController()
    roundController.addrounds(asList(
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7)),
            new Round()
                ..setRewards(600, 0)
                ..addMatchup(new Pair(0, 1))
                ..addMatchup(new Pair(2, 3))
                ..addMatchup(new Pair(4, 5))
                ..addMatchup(new Pair(6, 7))
        ))

    doAfter(2) ->
        roundController.roundSpawn()

    onRoundStart() (Round round) ->
        Log.info("Round start")
        pDatas.forEach() (player key, PlayerData value) ->
            pDatas.get(key).armyPoints = 0

    onLastArmyRemaining = () ->
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            u.unpause()
        Log.info("Clean up phase")
        altarEntity.showCounter()

    onAllUnitDead = (player winner) ->
        Log.info("All unit dead")
        roundController.checkIfCurrentroundDone(winner)

    onAllroundsFinished = () ->
        Log.info("Match over")

    onRoundFinish() (Round round) ->
        Log.info("Round finish")
        doAfter(3) ->
            altarEntity.hideCounter()
            let winner = round.winner
            printTimed(winner.getName() + " gets " + altarEntity.bloodPointCounter.toString() + " for winning the round" , 15)
            forUnitsAll() (unit u) ->
                if IsUnitDeadBJ(u)
                    u.remove()
        doAfter(5) ->
            if round.goldReward > 0
                printTimed("You get " + round.goldReward.toString() + " golds from round income", 15)
            if round.bloodPointReward > 0
                printTimed("You get " + round.bloodPointReward.toString() + " blood points from round income", 15)
            pDatas.forEach() (player key, PlayerData value) ->
                value.giveReward()
                key.addGold(round.goldReward)
                key.addLumber(round.bloodPointReward)


public function initUnitTrigger()
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
    ..addCondition(Condition(() -> GetDyingUnit().getPointValue() > 0))
    ..addAction() ->
        let killer = EventData.getKillingUnit().getOwner()
        let dying = EventData.getDyingUnit()

        let dyingOwner = dying.getOwner()

        let pData = pDatas.get(dying.getOwner())
        // Add blood points bounty
        if killer != ALTAR_PLAYER
            pDatas.get(killer).addBounty(dying.getPointValue())
            createTTEx(
                dying.getPos3Real(),
                "+" + dying.getPointValue().toString(),
                8,
                colorA(255, 0, 0, 255),
                killer
            )
            ..setVelocity(0.0, 0.03)
            ..setFadepoint(1.5)
            ..setLifespan(2.0)
            ..setPermanent(false)

        if pData.spawnedUnits.has(dying) == true
            pData.spawnedUnits.remove(dying)

        if pData.spawnedUnits.isEmpty()
            roundController.currentround.roundParticipant.remove(dyingOwner)

            Log.info("Removed " + dyingOwner.getName())

            if roundController.currentround.roundParticipant.size() == 1
                onLastArmyRemaining.execute()
            if roundController.currentround.roundParticipant.isEmpty()
                onAllUnitDead.execute(dyingOwner)
