package ArmySpawner

// Standard libs imports:
import ClosureEvents
import HashMap
import LinkedList

import Lodash

// Local imports:
import GameConstants
import GameStates
import LocalObjectIDs
import PlayerData
import PlayerExtension
import SpawnZone
import GameConfig
import UnitExtensions
import ItemCallbackDefinition



public function getUnitPointValue(int goldCost, int lumberCost, int unitCount) returns int
    var pointValue = 0
    pointValue += (goldCost / unitCount).toInt()
    pointValue += (lumberCost / unitCount / 10).toInt()
    return pointValue

public class BTBuildingData
    static let unitIdToDataMap = new HashMap<int, BTBuildingData>

    static function getUnitCount(int unitId) returns int
        return unitIdToDataMap.get(unitId).unitToSpawn.size()

    LinkedList<int> unitToSpawn
    int buildingArmyPoints = 0
    int unitPointValue = 0
    int goldCost = 0
    int lumberCost = 0

    construct(int buildingId, int goldCost, int lumberCost, LinkedList<int> unitToSpawn)
        unitIdToDataMap.put(buildingId, this)
        this.unitToSpawn = unitToSpawn
        this.goldCost = goldCost
        this.lumberCost = lumberCost
        unitPointValue = getUnitPointValue(goldCost, lumberCost, unitToSpawn.size())
        buildingArmyPoints += unitPointValue * unitToSpawn.size()

    construct(int upgradeFrom, int buildingId, int goldCost, int lumberCost, LinkedList<int> unitToSpawn)
        unitIdToDataMap.put(buildingId, this)
        this.unitToSpawn = unitToSpawn
        this.goldCost = goldCost
        this.lumberCost = lumberCost
        unitPointValue = getUnitPointValue(goldCost, lumberCost, unitToSpawn.size())
        buildingArmyPoints += unitPointValue * unitToSpawn.size()
        if unitIdToDataMap.get(upgradeFrom) != null
            unitPointValue += unitIdToDataMap.get(upgradeFrom).unitPointValue
            buildingArmyPoints += unitIdToDataMap.get(upgradeFrom).buildingArmyPoints
        else
            printLog(Loglevel.ERROR, "Unknown upgrade from id")


function genList(int unitId, int count) returns LinkedList<int>
    let unitList = new LinkedList<int>
    for i = 0 to count * 1 - 1
        unitList.add(unitId)
    return unitList

@compiletime function setupBuildingData()
// TODO: refactor, spawn count should be located in the unit definition files
    new BTBuildingData(BUILDING_FOOTMAN      , 50, 0   , genList(UNIT_FOOTMAN         , 5))
    new BTBuildingData(BUILDING_CAPTAIN  , 0  , 500 , genList(UNIT_CAPTAIN     , 10))
    new BTBuildingData(BUILDING_RIFLEMAN     , 100, 0   , genList(UNIT_RIFLEMAN        , 5))
    new BTBuildingData(BUILDING_ELVEN_ARCHER , 150, 0   , genList(UNIT_ELVEN_ARCHER    , 10))
    new BTBuildingData(BUILDING_RANGER       , 0  , 700 , genList(UNIT_RANGER          , 5))
    new BTBuildingData(BUILDING_KNIGHT       , 200, 0   , genList(UNIT_KNIGHT          , 5))
    new BTBuildingData(BUILDING_CRUSADER     , 0  , 1000, genList(UNIT_CRUSADER        , 5))
    new BTBuildingData(BUILDING_PRIEST       , 200, 0   , genList(UNIT_PRIEST          , 5))
    new BTBuildingData(BUILDING_SPELL_BREAKER, 0  , 1500, genList(UNIT_SPELL_BREAKER   , 4))
    new BTBuildingData(BUILDING_SORCERESS    , 150, 0   , genList(UNIT_SORCERESS       , 3))
    new BTBuildingData(BUILDING_MAGE         , 300, 0   , genList(UNIT_MAGE            , 3))
    new BTBuildingData(BUILDING_SWORD_MASTER , 0  , 3000, genList(UNIT_SWORD_MASTER    , 4))
    new BTBuildingData(BUILDING_ELVEN_MAGE   , 0  , 3000, genList(UNIT_ELVEN_MAGE      , 3))
    new BTBuildingData(BUILDING_PALADIN      , 0  , 1600, asList (UNIT_PALADIN_1       , UNIT_PALADIN_2, UNIT_PALADIN_3))
    new BTBuildingData(BUILDING_ARCHMAGE     , 0  , 2000, asList (UNIT_WATER_ELEMENTAL , UNIT_WATER_ELEMENTAL, UNIT_ARCHMAGE))

    new BTBuildingData(BUILDING_GRUNT                , 100 , 0   , genList(UNIT_GRUNT                , 4 ))
    new BTBuildingData(BUILDING_HEADHUNTER           , 150 , 0   , genList(UNIT_HEADHUNTER           , 10))
    new BTBuildingData(BUILDING_HEADHUNTER, BUILDING_TRAPPER              , 0   , 600 , genList(UNIT_TRAPPER              , 10))
    new BTBuildingData(BUILDING_RAIDER               , 250 , 0   , genList(UNIT_RAIDER               , 5 ))
    new BTBuildingData(BUILDING_WITCH_DOCTOR         , 150 , 0   , genList(UNIT_WITCH_DOCTOR         , 3 ))
    new BTBuildingData(BUILDING_SHAMAN               , 200 , 0   , genList(UNIT_SHAMAN               , 4 ))
    new BTBuildingData(BUILDING_OGRE                 , 300 , 0   , genList(UNIT_OGRE                 , 3 ))
    new BTBuildingData(BUILDING_WARLOCK              , 200 , 0   , genList(UNIT_WARLOCK              , 5 ))
    new BTBuildingData(BUILDING_TAUREN               , 200 , 0   , genList(UNIT_TAUREN               , 4 ))
    new BTBuildingData(BUILDING_OGRE_ARMORED         , 0   , 1200, genList(UNIT_OGRE_ARMORED         , 3 ))
    new BTBuildingData(BUILDING_BERSERKER            , 0   , 500 , genList(UNIT_BERSERKER            , 7 ))
    new BTBuildingData(BUILDING_HEADHUNTER_BERSERKER , 0   , 700 , genList(UNIT_HEADHUNTER_BERSERKER , 10))
    new BTBuildingData(BUILDING_PACK_LEADER          , 0   , 800 , genList(UNIT_PACK_LEADER          , 7 ))
    new BTBuildingData(BUILDING_FARSEER              , 0   , 1200, genList(UNIT_FARSEER              , 1 ))
    new BTBuildingData(BUILDING_OCCULTIST            , 0   , 900 , genList(UNIT_OCCULTIST            , 5 ))
    new BTBuildingData(BUILDING_BLADE_MASTER         , 0   , 3000, genList(UNIT_BLADE_MASTER         , 4 ))
    new BTBuildingData(BUILDING_SHADOW_HUNTER        , 0   , 3000, genList(UNIT_SHADOW_HUNTER        , 3 ))
    new BTBuildingData(BUILDING_DEMOLISHER           , 0   , 3000, genList(UNIT_DEMOLISHER           , 3 ))

    new BTBuildingData(BUILDING_ZOMBIE         , 50  , 0   , genList(UNIT_ZOMBIE          , 10 ))
    new BTBuildingData(BUILDING_ZOMBIE, BUILDING_GHOUL          , 0   , 600 , genList(UNIT_GHOUL           , 10 ))
    new BTBuildingData(BUILDING_SKELETAL_ARCHER, 150 , 0   , genList(UNIT_SKELETAL_ARCHER , 10 ))
    new BTBuildingData(BUILDING_CRYPT_FIEND    , 150 , 0   , genList(UNIT_CRYPT_FIEND     , 5  ))
    new BTBuildingData(BUILDING_NERUBIAN       , 0   , 800 , genList(UNIT_NERUBIAN        , 5  ))
    new BTBuildingData(BUILDING_NECROMANCER    , 200 , 0   , genList(UNIT_NECROMANCER     , 5  ))
    new BTBuildingData(BUILDING_LICH           , 0   , 1000, genList(UNIT_LICH            , 1  ))
    new BTBuildingData(BUILDING_DEATH_KNIGHT   , 0   , 1500, genList(UNIT_DEATH_KNIGHT    , 3  ))
    new BTBuildingData(BUILDING_BANSHEE        , 150 , 0   , genList(UNIT_BANSHEE         , 3  ))
    new BTBuildingData(BUILDING_ABOMINATION    , 300 , 0   , genList(UNIT_ABOMINATION     , 3  ))
    new BTBuildingData(BUILDING_FLESH_GOLEM    , 0   , 1400, genList(UNIT_FLESH_GOLEM     , 4  ))
    new BTBuildingData(BUILDING_VAMPIRE        , 350 , 0   , genList(UNIT_VAMPIRE         , 5  ))
    new BTBuildingData(BUILDING_VAMPIRE_LORD   , 0   , 1000, genList(UNIT_VAMPIRE_LORD    , 3  ))
    new BTBuildingData(BUILDING_CRYPT_LORD     , 0   , 3000, genList(UNIT_CRYPT_LORD      , 3  ))
    new BTBuildingData(BUILDING_DARK_RANGER    , 0   , 3000, genList(UNIT_DARK_RANGER     , 5  ))
    new BTBuildingData(BUILDING_ARCHIMONDE     , 0   , 3000, genList(UNIT_ARCHIMONDE      , 1  ))

    new BTBuildingData(BUILDING_TREANT                , 100 , 0   , genList(UNIT_TREANT                , 10 ))
    new BTBuildingData(BUILDING_ARCHER                , 100 , 0   , genList(UNIT_ARCHER                , 10  ))
    new BTBuildingData(BUILDING_ARCHER, BUILDING_NE_RANGER             , 0   , 1800, genList(UNIT_NE_RANGER             , 6  ))
    new BTBuildingData(BUILDING_HUNTRESS              , 200 , 0   , genList(UNIT_HUNTRESS              , 5  ))
    new BTBuildingData(BUILDING_DRUID_TALON           , 200 , 0   , genList(UNIT_DRUID_TALON           , 4  ))
    new BTBuildingData(BUILDING_DRUID_CLAW            , 250 , 0   , genList(UNIT_DRUID_CLAW            , 5  ))
    new BTBuildingData(BUILDING_OWLBEAR               , 0   , 1400, genList(UNIT_OWLBEAR               , 4  ))
    new BTBuildingData(BUILDING_DRYAD                 , 200 , 0   , genList(UNIT_DRYAD                 , 5  ))
    new BTBuildingData(BUILDING_ANCIENT_PROTECTOR     , 0   , 1600, genList(UNIT_ANCIENT_PROTECTOR     , 4  ))
    new BTBuildingData(BUILDING_MOUNTAIN_GIANT        , 300 , 0   , genList(UNIT_MOUNTAIN_GIANT        , 1  ))
    new BTBuildingData(BUILDING_SENTRY                , 150 , 0   , genList(UNIT_SENTRY                , 10 ))
    new BTBuildingData(BUILDING_SPECTRE               , 0   , 800 , genList(UNIT_SPECTRE               , 10 ))
    new BTBuildingData(BUILDING_WARDEN                , 0   , 1500, genList(UNIT_WARDEN                , 3  ))
    new BTBuildingData(BUILDING_AVATAR_OF_VENGEANCE   , 0   , 2100, genList(UNIT_AVATAR_OF_VENGEANCE   , 3  ))
    new BTBuildingData(BUILDING_BALLISTA              , 0   , 3000, genList(UNIT_BALLISTA              , 2  ))
    new BTBuildingData(BUILDING_DAEMON_HUNTER         , 0   , 3000, genList(UNIT_DAEMON_HUNTER         , 3  ))
    new BTBuildingData(BUILDING_PRIESTESS_OF_THE_MOON , 0   , 3000, genList(UNIT_PRIESTESS_OF_THE_MOON , 3  ))

    new BTBuildingData(BUILDING_GNOLL         , 0, 0, asList (UNIT_GNOLL          , UNIT_RAZORMAN, UNIT_WOLF, UNIT_FURBOLG, UNIT_SASQUATCH                                ))
    new BTBuildingData(BUILDING_GNOLL_UPGRADE , 0, 0, asList (UNIT_GNOLL_UPGRADE  , UNIT_RAZORMAN_UPGRADE, UNIT_WOLF_UPGRADE, UNIT_FURBOLG_UPGRADE, UNIT_SASQUATCH_UPGRADE))
    new BTBuildingData(BUILDING_TAUREN        , 0, 0, genList(UNIT_TAUREN         , 5                                                                                     ))
    new BTBuildingData(BUILDING_THUNDER_LIZARD, 0, 0, genList(UNIT_THUNDER_LIZARD , 4                                                                                     ))
    new BTBuildingData(BUILDING_CENTAUR       , 0, 0, genList(UNIT_CENTAUR        , 10                                                                                    ))
    new BTBuildingData(BUILDING_HYDRA         , 0, 0, genList(UNIT_HYDRA          , 3                                                                                     ))
    new BTBuildingData(BUILDING_REXXAR        , 0, 0, genList(UNIT_REXXAR         , 1                                                                                     ))
    new BTBuildingData(BUILDING_CHEN          , 0, 0, genList(UNIT_CHEN           , 1                                                                                     ))


// Distance between units positioned in formation mode
@configurable constant FORMATION_WIDTH = 120.
@configurable constant FORMATION_HEIGHT = 80.
@configurable constant MAX_UNIT_PER_PLAYER = 80

public let playerToArmySpawner = new HashMap<player, ArmySpawner>


public class ArmySpawner
    SpawnZone spawnZone
    player _p
    angle spawnDirection
    int buildingIdx = 0
    int squadIdx = 0
    vec2 pos
    LinkedList<unit> buildingList
    int unitPerLine
    PlayerData pData
    EventListener reinforcementListener
    boolean spawnFinished = false
    LinkedList<int> squadIds = new LinkedList<int>
    LinkedList<Pair<ItemModifyUnit, int>> unitModifierList = new LinkedList<Pair<ItemModifyUnit, int>>

    construct(player _p)
        // Log.info("[ArmySpawner] [construct]")
        this._p = _p
        this.pData = pDatas.get(_p)
        this.initReinforcementListener()

    function setBuildingList(LinkedList<unit> buildingList)
        this.buildingList = buildingList

    function executeItemBonus(LinkedList<item> inv)
        inv.forEach() (item itm) ->
            if itemAddUnitMap.has(itm.getTypeId())
                itemAddUnitMap.get(itm.getTypeId()).execute(squadIds, itm.getCharges())
            if itemModifyUnitMap.has(itm.getTypeId())
                unitModifierList.push(new Pair(itemModifyUnitMap.get(itm.getTypeId()), itm.getCharges()))

    function setSpawnZone(SpawnZone spawnZone)
        this.spawnZone = spawnZone
        this.spawnDirection = (spawnZone.angle.cos() == 0 ? 0 : 90).asAngleDegrees()
        this.pos = spawnZone.initialPos

    function spawnUnit(int unitId, vec2 spawnPos) returns unit
        let spawnedUnits = pDatas.get(_p).spawnedUnits
        let dummyPlayerIdx = spawnedUnits.size() div MAX_UNIT_PER_PLAYER mod pDatas.get(_p).dummyPlayers.size()

        let newUnit = createUnit(_p.getDummyPlayer(dummyPlayerIdx), unitId, spawnPos, spawnZone.angle)
        if gameConfig.getHealthMultiplier() != 1.
            newUnit.setHP(newUnit.getHP() * gameConfig.getHealthMultiplier())
        if gameConfig.getDamageMultiplier() != 1.
            newUnit.setBaseDamage(
                (newUnit.getBaseDamage(0) * gameConfig.getDamageMultiplier()).toInt() , 0)

        if not unitModifierList.isEmpty()
            unitModifierList.get(0).a.execute(newUnit)
            unitModifierList.get(0).b -= 1
            if unitModifierList.get(0).b <= 0
                destroy unitModifierList.dequeue()

        BlzShowUnitTeamGlow(newUnit, false)
        if newUnit.getName() == ""
            Log.info("Unknown unit spawned")
            newUnit.kill()
        else
            pData.spawnedUnits.add(newUnit)
        return newUnit

    function spawnArmy()
        squadIds.clear()
        buildingIdx = 0
        squadIdx = 0
        // let pData = pDatas.get(_p)
        spawnFinished = false
        // TODO: Add to gameConfig?
        // Determine number of unit per line
        unitPerLine = spawnDirection.degrees() == 0.
            ? (spawnZone.width /  FORMATION_WIDTH).round()
            : (spawnZone.height / FORMATION_WIDTH).round()

        if buildingList.isEmpty()
            spawnUnit(UNIT_DUMMY_SOLDIER, pos)

        while buildingIdx < buildingList.size() and pData.spawnedUnits.size() < spawnZone.unitLimit
            // Get list of unit mapped to the building
            let building = buildingList.get(buildingIdx)
            // Log.info("Spawning " + building.getName())
            squadIds.addAll(BTBuildingData.unitIdToDataMap.get(building.getTypeId()).unitToSpawn)

            executeItemBonus(building.getInventory())

            // Spawn while there's something to spawn and unitLimit isn't reached
            while squadIdx < squadIds.size() and pData.spawnedUnits.size() < spawnZone.unitLimit
                spawnUnit(squadIds.get(squadIdx), pos)
                // Pause unit until battle start
                ..pause()

                // Update position for next unit
                pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)

                // Move to next line
                if pData.spawnedUnits.size() % unitPerLine == 0
                    pos = spawnZone.initialPos.polarOffset(
                        spawnZone.angle.op_minus(180..asAngleDegrees()),
                        FORMATION_HEIGHT * pData.spawnedUnits.size() / unitPerLine)
                squadIdx++
            squadIdx = 0
            squadIds.clear()
            buildingIdx++
        if isBuildingSpawnOver() and isSquadSpawnOver()
            spawnFinished = true

        // Set position to the reinforcement spawn point
        // 400 is kind of a random value
        let invertedAngle = (180 + spawnZone.angle.degrees() % 360).asAngleDegrees()
        pos = spawnZone.spawnRect.getCenter().polarOffset(invertedAngle, 400)
        if not isProdBuild
            createTTEx(pos.withZ(100.), invertedAngle.degrees().toString(), 10)
            createTTEx(pos.withZ(300.), invertedAngle.direction().toString(), 10)
        // Log.info("Position reserve : " + pos.toString())

    private function isBuildingSpawnOver() returns boolean
        return buildingIdx >= buildingList.size()

    private function isSquadSpawnOver() returns boolean
        if isBuildingSpawnOver()
            return true
        return squadIdx >= squadIds.size()

    private function getRandomReinforcementPos() returns vec2
        let spawnRect = spawnZone.spawnRect
        let offset = (spawnZone.angle.cos() == 0 ? spawnRect.height() / 2 : spawnRect.width() / 2)
        if spawnZone.angle.cos() == 0
            return pos + vec2(GetRandomReal(-offset, offset), 0)
        else
            return pos + vec2(0, GetRandomReal(-offset, offset))

    private function spawnReinforcement()
        if squadIds.isEmpty()
            let building = buildingList.get(buildingIdx)
            squadIds.addAll(BTBuildingData.unitIdToDataMap.get(building.getTypeId()).unitToSpawn)
            executeItemBonus(building.getInventory())

        let unitId = squadIds.get(squadIdx)
        spawnUnit(unitId, getRandomReinforcementPos())
            ..issuePointOrder("attack", CENTER)

        squadIdx++
        if isSquadSpawnOver()
            squadIdx = 0
            buildingIdx++
            squadIds.clear()
            if isBuildingSpawnOver()
                spawnFinished = true

    private function initReinforcementListener()
        reinforcementListener = EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
            let dying = EventData.getDyingUnit()
            let dyingOwner = dying.getOwner().getTruePlayerFromDummy()
            if dyingOwner == this._p
                and not spawnFinished
                and dying.getPointValue() > 0
                spawnReinforcement()


// TODO: replace with gamestate functional interface just like in ITTs
public function initArmySpawner()
    setupBuildingData()
    for i = 0 to 7
        playerToArmySpawner.put(players[i], new ArmySpawner(players[i]))
