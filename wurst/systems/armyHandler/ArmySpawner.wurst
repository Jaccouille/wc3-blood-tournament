package ArmySpawner

import LinkedList

import SpawnZone
import ClosureEvents
import ClosureTimers

import ScoreBoard
import HashMap
import LocalObjectIDs
import GameStates
import GameConstants

public let armyMap = new HashMap<int, LinkedList<int>>
    ..put(BUILDING_FOOTMAN  , generateUnitList(UNIT_FOOTMAN  , 20))
    ..put(BUILDING_RIFLEMAN , generateUnitList(UNIT_RIFLEMAN , 5))
    ..put(BUILDING_KNIGHT   , generateUnitList(UNIT_KNIGHT   , 5))
    ..put(BUILDING_PRIEST   , generateUnitList(UNIT_PRIEST   , 4))
    ..put(BUILDING_SORCERESS, generateUnitList(UNIT_SORCERESS, 4))
    ..put(BUILDING_ARCHMAGE , generateUnitList(UNIT_ARCHMAGE , 1))
    ..put(BUILDING_PALADIN  , generateUnitList(UNIT_PALADIN  , 1))

    ..put(BUILDING_GRUNT        , generateUnitList(UNIT_GRUNT        , 10))
    ..put(BUILDING_HEADHUNTER   , generateUnitList(UNIT_HEADHUNTER   , 5))
    ..put(BUILDING_WARLOCK      , generateUnitList(UNIT_WARLOCK      , 5))
    ..put(BUILDING_SHAMAN       , generateUnitList(UNIT_SHAMAN       , 4))
    ..put(BUILDING_TAUREN       , generateUnitList(UNIT_TAUREN       , 4))
    ..put(BUILDING_CHIEFTAIN    , generateUnitList(UNIT_CHIEFTAIN    , 1))
    ..put(BUILDING_SHADOWHUNTER , generateUnitList(UNIT_SHADOWHUNTER , 1))

    ..put(BUILDING_GHOUL       , generateUnitList(UNIT_GHOUL       , 30))
    ..put(BUILDING_CRYPT_FIEND , generateUnitList(UNIT_CRYPT_FIEND , 5))
    ..put(BUILDING_NECROMANCER , generateUnitList(UNIT_NECROMANCER , 5))
    ..put(BUILDING_BANSHEE     , generateUnitList(UNIT_BANSHEE     , 4))
    ..put(BUILDING_ABOMINATION , generateUnitList(UNIT_ABOMINATION , 4))
    ..put(BUILDING_DREADLORD   , generateUnitList(UNIT_DREADLORD   , 1))
    ..put(BUILDING_LICH        , generateUnitList(UNIT_LICH        , 1))

    ..put(BUILDING_TREANT                , generateUnitList(UNIT_TREANT                , 10))
    ..put(BUILDING_ARCHER                , generateUnitList(UNIT_ARCHER                , 15))
    ..put(BUILDING_HUNTRESS              , generateUnitList(UNIT_HUNTRESS              , 5))
    ..put(BUILDING_DRUID_TALON           , generateUnitList(UNIT_DRUID_TALON           , 4))
    ..put(BUILDING_DRUID_CLAW_BEAR       , generateUnitList(UNIT_DRUID_CLAW_BEAR       , 4))
    ..put(BUILDING_DAEMON_HUNTER         , generateUnitList(UNIT_DAEMON_HUNTER         , 1))
    ..put(BUILDING_PRIESTESS_OF_THE_MOON , generateUnitList(UNIT_PRIESTESS_OF_THE_MOON , 1))

function generateUnitList(int unitId, int count) returns LinkedList<int>
    let unitList = new LinkedList<int>
    for i = 0 to count * 1 - 1
        unitList.add(unitId)
    return unitList


// Distance between units positioned in formation mode
@configurable constant FORMATION_WIDTH = 120.
@configurable constant FORMATION_HEIGHT = 80.

public let playerToArmySpawner = new HashMap<player, ArmySpawner>

public var count = 0

public class ArmySpawner
    SpawnZone spawnZone
    player _p
    angle spawnDirection
    int idx = 0
    int nestedIdx = 0
    int unitSpawned = 0
    vec2 pos
    constant unitReserve = new LinkedList<unit>
    int unitPerLine
    PlayerData pData

    construct(player _p)
        // Log.info("[ArmySpawner] [construct]")
        this._p = _p
        this.pData = pDatas.get(_p)

    function setSpawnZone(SpawnZone spawnZone)
        this.spawnZone = spawnZone
        this.spawnDirection = (spawnZone.angle.cos() == 0 ? 0 : 90).asAngleDegrees()
        this.pos = spawnZone.initialPos

    function spawnUnit(int unitId)
        let newUnit = createUnit(_p, unitId, pos, spawnZone.angle)
        // Pause unit until battle start
        newUnit.pause()
        pData.spawnedUnits.add(newUnit)

        // TODO: Move this to army parsing
        let armyPoints = newUnit.getPointValue()
        pData.addArmyPoints(armyPoints)
        scoreBoardEntries.get("ArmyPoints").addValue(_p, armyPoints)

        if unitSpawned < spawnZone.unitLimit
            // Update position for next unit
            pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)

            // Move to next line
            if (unitSpawned + 1) % unitPerLine == 0
                pos = spawnZone.initialPos.polarOffset(
                    spawnZone.angle.op_minus(180..asAngleDegrees()),
                    FORMATION_HEIGHT * unitSpawned / unitPerLine)
        else
            // Set reinforcement reserve
            newUnit.hide()
            newUnit.setPos(gg_rct_backupSpawn.getCenter())
            unitReserve.push(newUnit)
        nestedIdx++
        count++
        unitSpawned++
    // nestedIdx = 0
    // idx++

    function test(LinkedList<unit> buildingList)
        let bIterator = buildingList.iterator()
        let squadIds = armyMap.get(bIterator.next().getTypeId())
        var sIterator = squadIds.iterator()
        doPeriodically(0.003) (CallbackPeriodic cb) ->
            if sIterator.hasNext()
                spawnUnit(sIterator.next())
            else
                sIterator.close()
                if bIterator.hasNext()
                    sIterator = armyMap.get(bIterator.next().getTypeId()).iterator()
                else
                    bIterator.close()
                    destroy cb

    function spawnArmy(LinkedList<unit> buildingList)
        idx = 0
        nestedIdx = 0
        unitSpawned = 0
        // let pData = pDatas.get(_p)

        // TODO: Add to gameConfig?
        // Determine number of unit per line
        unitPerLine = spawnDirection.degrees() == 0.
            ? (spawnZone.width /  FORMATION_WIDTH).round()
            : (spawnZone.height / FORMATION_WIDTH).round()
        test(buildingList)

        // while idx < buildingList.size() and unitSpawned < spawnZone.unitLimit
        //     // Get list of unit mapped to the building
        //     let building = buildingList.get(idx)
        //     let squadIds = armyMap.get(building.getTypeId())
        //     doPeriodicallyCounted(0.005, squadIds.size()) (CallbackCounted cb) ->
        //         let newUnit = createUnit(_p, squadIds.get(nestedIdx), pos, spawnZone.angle)
        //         // Pause unit until battle start
        //         newUnit.pause()
        //         pData.spawnedUnits.add(newUnit)

        //         // TODO: Move this to army parsing
        //         let armyPoints = newUnit.getPointValue()
        //         pData.addArmyPoints(armyPoints)
        //         scoreBoardEntries.get("ArmyPoints").addValue(_p, armyPoints)

        //         if unitSpawned < spawnZone.unitLimit
        //             // Update position for next unit
        //             pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)

        //             // Move to next line
        //             if (unitSpawned + 1) % unitPerLine == 0
        //                 pos = spawnZone.initialPos.polarOffset(
        //                     spawnZone.angle.op_minus(180..asAngleDegrees()),
        //                     FORMATION_HEIGHT * unitSpawned / unitPerLine)
        //         else
        //             // Set reinforcement reserve
        //             newUnit.hide()
        //             newUnit.setPos(gg_rct_backupSpawn.getCenter())
        //             unitReserve.push(newUnit)
        //         nestedIdx++
        //         count++
        //         unitSpawned++
        //         Log.info("Count : " + count.toString())
        //         Log.info("NestedIdx : " + nestedIdx.toString())
        //         if nestedIdx < squadIds.size() and count < 1000
        //             destroy cb
        //     nestedIdx = 0
        //     idx++

        // Set position to the reinforcement spawn point
        // 300 is kind of a random value
        pos = spawnZone.spawnRect.getCenter().polarOffset(spawnDirection.op_minus(180..asAngleDegrees()), 300)
        // Log.info("Position reserve : " + pos.toString())

// TODO: replace with gamestate functional interface just like in ITTs
public function initArmySpawner()
    for i = 0 to 7
        playerToArmySpawner.put(players[i], new ArmySpawner(players[i]))

    GameStates.gameplay.onEnter() state ->
        EventListener.add(EVENT_PLAYER_UNIT_CONSTRUCT_FINISH) ->
            let u = EventData.getTriggerUnit()
            let pData = pDatas.get(u.getOwner())
            let buildingList = pData.buildingList

            if armyMap.has(u.getTypeId())
                if buildingList.size() == 0
                    buildingList.add(u)

                // Insert new building so the list is sorted by top left position
                // Descending
                for building in buildingList

                    // TODO: refactor? Code seems a bit ugly
                    if u.getPos().x > building.getPos().x
                        if buildingList.indexOf(building) == 0
                            buildingList.addtoStart(u)
                        else
                            buildingList.addAt(u, buildingList.indexOf(building) - 1)
                        break
                    else if u.getPos().x == building.getPos().x
                        if u.getPos().y > building.getPos().y
                            buildingList.addAt(u, buildingList.indexOf(building) - 1)
                            break

                if not buildingList.has(u)
                    buildingList.push(u)

        EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
            let u = EventData.getDyingUnit()
            let owner = u.getOwner()

            if armyMap.has(u.getTypeId())
                pDatas.get(owner).buildingList.remove(u)

            let spawner = playerToArmySpawner.get(owner)

            if spawner.unitReserve.size() > 0
                spawner.unitReserve.dequeue()
                    ..setPos(spawner.pos)
                    ..show()
                    ..unpause()
                    ..issuePointOrder("attack", CENTER)
