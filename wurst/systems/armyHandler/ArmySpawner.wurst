package ArmySpawner

// Standard libs imports:
import Assets
import ClosureEvents
import ClosureTimers
import HashMap
import LinkedList

// Local imports:
import GameConstants
import GameStates
import LocalObjectIDs
import PlayerData
import PlayerExtension
import SpawnZone
import UnitPointValueMap
import GameConfig

class BuildingTemplate
    LinkedList<int> unitToSpawn
    int pointValue = 0

    construct(LinkedList<int> unitToSpawn)
        this.unitToSpawn = unitToSpawn
        unitToSpawn.forEach() (integer unitId) ->
            pointValue += unitToPoint.get(unitId)

public let armyMap = new HashMap<int, BuildingTemplate>
    ..put(BUILDING_FOOTMAN           , new BuildingTemplate(generateUnitList(UNIT_FOOTMAN           , 10                            )))
    ..put(BUILDING_ROYAL_GUARD       , new BuildingTemplate(generateUnitList(UNIT_ROYAL_GUARD       , 10                            )))
    ..put(BUILDING_ELVEN_ARCHER      , new BuildingTemplate(generateUnitList(UNIT_ELVEN_ARCHER      , 10                            )))
    ..put(BUILDING_RANGER            , new BuildingTemplate(generateUnitList(UNIT_RANGER            , 5                             )))
    ..put(BUILDING_KNIGHT            , new BuildingTemplate(generateUnitList(UNIT_KNIGHT            , 5                             )))
    ..put(BUILDING_CRUSADER          , new BuildingTemplate(generateUnitList(UNIT_CRUSADER          , 5                             )))
    ..put(BUILDING_PALADIN           , new BuildingTemplate(asList(UNIT_PALADIN_1, UNIT_PALADIN_2, UNIT_PALADIN_3)))
    ..put(BUILDING_PRIEST            , new BuildingTemplate(generateUnitList(UNIT_PRIEST            , 4                             )))
    ..put(BUILDING_SPELL_BREAKER     , new BuildingTemplate(generateUnitList(UNIT_SPELL_BREAKER     , 4                             )))
    ..put(BUILDING_SORCERESS         , new BuildingTemplate(generateUnitList(UNIT_SORCERESS         , 4                             )))
    ..put(BUILDING_SORCERESS_UPGRADE , new BuildingTemplate(generateUnitList(UNIT_SORCERESS_UPGRADE , 3                             )))
    ..put(BUILDING_MAGE              , new BuildingTemplate(generateUnitList(UNIT_MAGE              , 3                             )))
    ..put(BUILDING_ARCHMAGE          , new BuildingTemplate(generateUnitList(UNIT_ARCHMAGE          , 1                             )))
    ..put(BUILDING_SWORD_MASTER      , new BuildingTemplate(generateUnitList(UNIT_SWORD_MASTER      , 4                             )))
    ..put(BUILDING_ELVEN_MAGE        , new BuildingTemplate(generateUnitList(UNIT_ELVEN_MAGE        , 3                             )))
    ..put(BUILDING_RIFLEMAN          , new BuildingTemplate(generateUnitList(UNIT_RIFLEMAN          , 5                             )))

    ..put(BUILDING_GRUNT                , new BuildingTemplate(generateUnitList(UNIT_GRUNT                , 7  )))
    ..put(BUILDING_WARLOCK              , new BuildingTemplate(generateUnitList(UNIT_WARLOCK              , 5  )))
    ..put(BUILDING_HEADHUNTER           , new BuildingTemplate(generateUnitList(UNIT_HEADHUNTER           , 10 )))
    ..put(BUILDING_SHAMAN               , new BuildingTemplate(generateUnitList(UNIT_SHAMAN               , 4  )))
    ..put(BUILDING_TAUREN               , new BuildingTemplate(generateUnitList(UNIT_TAUREN               , 4  )))
    ..put(BUILDING_RAIDER               , new BuildingTemplate(generateUnitList(UNIT_RAIDER               , 4  )))
    ..put(BUILDING_OGRE                 , new BuildingTemplate(generateUnitList(UNIT_OGRE                 , 4  )))
    ..put(BUILDING_OGRE_ARMORED         , new BuildingTemplate(generateUnitList(UNIT_OGRE_ARMORED         , 4  )))
    ..put(BUILDING_BERSERKER            , new BuildingTemplate(generateUnitList(UNIT_BERSERKER            , 7  )))
    ..put(BUILDING_TRAPPER              , new BuildingTemplate(generateUnitList(UNIT_TRAPPER              , 10 )))
    ..put(BUILDING_HEADHUNTER_BERSERKER , new BuildingTemplate(generateUnitList(UNIT_HEADHUNTER_BERSERKER , 10 )))
    ..put(BUILDING_WARMONGER            , new BuildingTemplate(generateUnitList(UNIT_WARMONGER            , 7  )))
    ..put(BUILDING_FARSEER              , new BuildingTemplate(generateUnitList(UNIT_FARSEER              , 4  )))
    ..put(BUILDING_OCCULTIST            , new BuildingTemplate(generateUnitList(UNIT_OCCULTIST            , 5  )))
    ..put(BUILDING_BLADE_MASTER         , new BuildingTemplate(generateUnitList(UNIT_BLADE_MASTER         , 4  )))
    ..put(BUILDING_SHADOW_HUNTER        , new BuildingTemplate(generateUnitList(UNIT_SHADOW_HUNTER        , 3  )))
    ..put(BUILDING_DEMOLISHER           , new BuildingTemplate(generateUnitList(UNIT_DEMOLISHER           , 3  )))

    ..put(BUILDING_GHOUL       , new BuildingTemplate(generateUnitList(UNIT_GHOUL       , 30)))
    ..put(BUILDING_CRYPT_FIEND , new BuildingTemplate(generateUnitList(UNIT_CRYPT_FIEND , 5)))
    ..put(BUILDING_NECROMANCER , new BuildingTemplate(generateUnitList(UNIT_NECROMANCER , 5)))
    ..put(BUILDING_BANSHEE     , new BuildingTemplate(generateUnitList(UNIT_BANSHEE     , 4)))
    ..put(BUILDING_ABOMINATION , new BuildingTemplate(generateUnitList(UNIT_ABOMINATION , 4)))
    ..put(BUILDING_LICH        , new BuildingTemplate(generateUnitList(UNIT_LICH        , 1)))

    ..put(BUILDING_ZOMBIE         , new BuildingTemplate(generateUnitList(UNIT_ZOMBIE         , 10)))
    ..put(BUILDING_REVENANT       , new BuildingTemplate(generateUnitList(UNIT_REVENANT       , 5)))
    ..put(BUILDING_NERUBIAN       , new BuildingTemplate(generateUnitList(UNIT_NERUBIAN       , 5)))
    ..put(BUILDING_VAMPIRE        , new BuildingTemplate(generateUnitList(UNIT_VAMPIRE        , 5)))
    ..put(BUILDING_GREATER_VAMPIRE, new BuildingTemplate(generateUnitList(UNIT_GREATER_VAMPIRE, 3)))
    ..put(BUILDING_FLESH_GOLEM    , new BuildingTemplate(generateUnitList(UNIT_FLESH_GOLEM    , 4)))
    ..put(BUILDING_DARK_RANGER    , new BuildingTemplate(generateUnitList(UNIT_DARK_RANGER    , 5)))
    ..put(BUILDING_CRYPT_LORD     , new BuildingTemplate(generateUnitList(UNIT_CRYPT_LORD     , 3)))
    ..put(BUILDING_DEATH_KNIGHT   , new BuildingTemplate(generateUnitList(UNIT_DEATH_KNIGHT   , 3)))
    ..put(BUILDING_ARCHIMONDE     , new BuildingTemplate(generateUnitList(UNIT_ARCHIMONDE     , 1)))

    ..put(BUILDING_TREANT                , new BuildingTemplate(generateUnitList(UNIT_TREANT                , 10)))
    ..put(BUILDING_ARCHER                , new BuildingTemplate(generateUnitList(UNIT_ARCHER                , 15)))
    ..put(BUILDING_HUNTRESS              , new BuildingTemplate(generateUnitList(UNIT_HUNTRESS              , 5 )))
    ..put(BUILDING_DRUID_TALON           , new BuildingTemplate(generateUnitList(UNIT_DRUID_TALON           , 4 )))
    ..put(BUILDING_DRUID_CLAW_BEAR       , new BuildingTemplate(generateUnitList(UNIT_DRUID_CLAW_BEAR       , 4 )))
    ..put(BUILDING_DAEMON_HUNTER         , new BuildingTemplate(generateUnitList(UNIT_DAEMON_HUNTER         , 3 )))
    ..put(BUILDING_PRIESTESS_OF_THE_MOON , new BuildingTemplate(generateUnitList(UNIT_PRIESTESS_OF_THE_MOON , 3 )))
    ..put(BUILDING_OWLBEAR               , new BuildingTemplate(generateUnitList(UNIT_OWLBEAR               , 4 )))
    ..put(BUILDING_DRYAD                 , new BuildingTemplate(generateUnitList(UNIT_DRYAD                 , 7 )))
    ..put(BUILDING_FURION                , new BuildingTemplate(generateUnitList(UNIT_FURION               , 1 )))

    ..put(BUILDING_ANCIENT_PROTECTOR  , new BuildingTemplate(generateUnitList(UNIT_ANCIENT_PROTECTOR  , 4)))
    ..put(BUILDING_NE_RANGER          , new BuildingTemplate(generateUnitList(UNIT_NE_RANGER          , 6)))
    ..put(BUILDING_SENTRY             , new BuildingTemplate(generateUnitList(UNIT_SENTRY             , 10)))
    ..put(BUILDING_SPECTRE            , new BuildingTemplate(generateUnitList(UNIT_SPECTRE            , 10)))
    ..put(BUILDING_ARCH_DRUID         , new BuildingTemplate(generateUnitList(UNIT_ARCH_DRUID         , 3)))
    ..put(BUILDING_WARDEN             , new BuildingTemplate(generateUnitList(UNIT_WARDEN             , 3)))
    ..put(BUILDING_AVATAR_OF_VENGEANCE, new BuildingTemplate(generateUnitList(UNIT_AVATAR_OF_VENGEANCE, 3)))
    ..put(BUILDING_BALLISTA           , new BuildingTemplate(generateUnitList(UNIT_BALLISTA           , 2)))


    ..put(BUILDING_GNOLL           , new BuildingTemplate(asList(UNIT_GNOLL,UNIT_RAZORMAN, UNIT_WOLF, UNIT_FURBOLG, UNIT_SASQUATCH)))
    ..put(BUILDING_GNOLL_UPGRADE   , new BuildingTemplate(asList(UNIT_GNOLL_UPGRADE, UNIT_RAZORMAN_UPGRADE, UNIT_WOLF_UPGRADE, UNIT_FURBOLG_UPGRADE, UNIT_SASQUATCH_UPGRADE)))
    ..put(BUILDING_TAUREN          , new BuildingTemplate(generateUnitList(UNIT_TAUREN          , 5)))
    ..put(BUILDING_THUNDER_LIZARD  , new BuildingTemplate(generateUnitList(UNIT_THUNDER_LIZARD  , 4)))
    ..put(BUILDING_CENTAUR         , new BuildingTemplate(generateUnitList(UNIT_CENTAUR         , 10)))
    ..put(BUILDING_HYDRA           , new BuildingTemplate(generateUnitList(UNIT_HYDRA           , 3)))
    ..put(BUILDING_REXXAR          , new BuildingTemplate(generateUnitList(UNIT_REXXAR          , 1)))
    ..put(BUILDING_CHEN            , new BuildingTemplate(generateUnitList(UNIT_CHEN            , 1)))


function generateUnitList(int unitId, int count) returns LinkedList<int>
    let unitList = new LinkedList<int>
    for i = 0 to count * 1 - 1
        unitList.add(unitId)
    return unitList


// Distance between units positioned in formation mode
@configurable constant FORMATION_WIDTH = 120.
@configurable constant FORMATION_HEIGHT = 80.
@configurable constant MAX_UNIT_PER_PLAYER = 80

public let playerToArmySpawner = new HashMap<player, ArmySpawner>


public class ArmySpawner
    SpawnZone spawnZone
    player _p
    angle spawnDirection
    int idx = 0
    int nestedIdx = 0
    vec2 pos
    LinkedList<unit> buildingList
    int unitPerLine
    PlayerData pData
    EventListener reinforcementListener
    boolean spawnFinished = false

    construct(player _p)
        // Log.info("[ArmySpawner] [construct]")
        this._p = _p
        this.pData = pDatas.get(_p)
        this.initReinforcementListener()

    function setBuildingList(LinkedList<unit> buildingList)
        this.buildingList = buildingList

    function setSpawnZone(SpawnZone spawnZone)
        this.spawnZone = spawnZone
        this.spawnDirection = (spawnZone.angle.cos() == 0 ? 0 : 90).asAngleDegrees()
        this.pos = spawnZone.initialPos

    function spawnUnit(int unitId, vec2 spawnPos)
        let spawnedUnits = pDatas.get(_p).spawnedUnits
        let dummyPlayerIdx = spawnedUnits.size() div MAX_UNIT_PER_PLAYER mod pDatas.get(_p).dummyPlayers.size()

        let newUnit = createUnit(_p.getDummyPlayer(dummyPlayerIdx), unitId, spawnPos, spawnZone.angle)
        if gameConfig.getHealthMultiplier() != 1.
            newUnit.setHP(newUnit.getHP() * gameConfig.getHealthMultiplier())
        if gameConfig.getDamageMultiplier() != 1.
            newUnit.setBaseDamage(
                (newUnit.getBaseDamage(0) * gameConfig.getDamageMultiplier()).toInt() , 0)

        // Pause unit until battle start
        BlzShowUnitTeamGlow(newUnit, false)
        newUnit.pause()
        if newUnit.getName() == ""
            Log.info("Unknown unit spawned")
            newUnit.kill()
        else
            pData.spawnedUnits.add(newUnit)


    function spawnArmy()
        idx = 0
        nestedIdx = 0
        // let pData = pDatas.get(_p)
        spawnFinished = false
        // TODO: Add to gameConfig?
        // Determine number of unit per line
        unitPerLine = spawnDirection.degrees() == 0.
            ? (spawnZone.width /  FORMATION_WIDTH).round()
            : (spawnZone.height / FORMATION_WIDTH).round()

        if buildingList.isEmpty()
            spawnUnit(UNIT_DUMMY_SOLDIER, pos)

        while idx < buildingList.size() and pData.spawnedUnits.size() < spawnZone.unitLimit
            // Get list of unit mapped to the building
            let building = buildingList.get(idx)
            let squadIds = armyMap.get(building.getTypeId())

            // Spawn while there's something to spawn and unitLimit isn't reached
            while nestedIdx < squadIds.unitToSpawn.size() and pData.spawnedUnits.size() < spawnZone.unitLimit
                spawnUnit(squadIds.unitToSpawn.get(nestedIdx), pos)

                // Update position for next unit
                pos = pos.polarOffset(spawnDirection, FORMATION_WIDTH)

                // Move to next line
                if (pData.spawnedUnits.size() + 1) % unitPerLine == 0
                    pos = spawnZone.initialPos.polarOffset(
                        spawnZone.angle.op_minus(180..asAngleDegrees()),
                        FORMATION_HEIGHT * pData.spawnedUnits.size() / unitPerLine)
                nestedIdx++
            nestedIdx = 0
            idx++
        if isBuildingSpawnOver() and isSquadSpawnOver()
            spawnFinished = true

        // Set position to the reinforcement spawn point
        // 400 is kind of a random value
        let invertedAngle = (180 + spawnZone.angle.degrees() % 360).asAngleDegrees()
        pos = spawnZone.spawnRect.getCenter().polarOffset(invertedAngle, 400)
        if not isProdBuild
            let efx = addEffect(Abilities.divineShieldTarget, pos)..setScale(0.5)
            createTTEx(pos.withZ(100.), invertedAngle.degrees().toString(), 10)
            createTTEx(pos.withZ(300.), invertedAngle.direction().toString(), 10)
            doAfter(10) ->
                efx.destr()
        // Log.info("Position reserve : " + pos.toString())

    private function isBuildingSpawnOver() returns boolean
        return idx >= buildingList.size()

    private function isSquadSpawnOver() returns boolean
        if isBuildingSpawnOver()
            return true
        let building = buildingList.get(idx)
        let squadIds = armyMap.get(building.getTypeId())
        return nestedIdx >= squadIds.unitToSpawn.size()

    private function getRandomReinforcementPos() returns vec2
        let spawnRect = spawnZone.spawnRect
        let offset = (spawnZone.angle.cos() == 0 ? spawnRect.height() / 2 : spawnRect.width() / 2)
        if spawnZone.angle.cos() == 0
            return pos + vec2(GetRandomReal(-offset, offset), 0)
        else
            return pos + vec2(0, GetRandomReal(-offset, offset))

    private function spawnReinforcement()
        let building = buildingList.get(idx)
        // Log.info("idx " + idx.toString() + " building size " + buildingList.size().toString())
        // Log.info("spawn finished " + spawnFinished.toString() + " for " + pData._p.getNameColored(true))
        let squadIds = armyMap.get(building.getTypeId()).unitToSpawn
        // Log.info("Nested idx " + nestedIdx.toString() + " squad size " + squadIds.size().toString())
        let unitId = squadIds.get(nestedIdx)
        spawnUnit(unitId, getRandomReinforcementPos())

        nestedIdx++
        if isSquadSpawnOver()
            nestedIdx = 0
            idx++
            if isBuildingSpawnOver()
                spawnFinished = true

    private function initReinforcementListener()
        reinforcementListener = EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
            let dying = EventData.getDyingUnit()
            let dyingOwner = dying.getOwner().getTruePlayerFromDummy()
            if dyingOwner == this._p
                and not spawnFinished
                and unitToPoint.has(dying.getTypeId())
                spawnReinforcement()


// TODO: replace with gamestate functional interface just like in ITTs
public function initArmySpawner()
    for i = 0 to 7
        playerToArmySpawner.put(players[i], new ArmySpawner(players[i]))

    GameStates.gameplay.onEnter() state ->

        EventListener.add(EVENT_PLAYER_UNIT_UPGRADE_FINISH) ->
            let u = EventData.getTriggerUnit()
            BlzShowUnitTeamGlow(u, false)

        EventListener.add(EVENT_PLAYER_UNIT_CONSTRUCT_FINISH) ->
            let u = EventData.getTriggerUnit()
            let pData = pDatas.get(u.getOwner())
            let buildingList = pData.buildingList

            BlzShowUnitTeamGlow(u, false)

            if armyMap.has(u.getTypeId())
                // Not need to find insertion index if list is empty
                if buildingList.size() == 0
                    buildingList.add(u)

                // Insert new building so the list is sorted by top left position
                // Descending
                for building in buildingList

                    // TODO: refactor? Code seems a bit ugly
                    if u.getPos().x > building.getPos().x
                        if buildingList.indexOf(building) == 0
                            buildingList.addtoStart(u)
                        else
                            buildingList.addAt(u, buildingList.indexOf(building) - 1)
                        break
                    else if u.getPos().x == building.getPos().x
                        if u.getPos().y > building.getPos().y
                            buildingList.addAt(u, buildingList.indexOf(building) - 1)
                            break

                if not buildingList.has(u)
                    buildingList.push(u)

                pData.addArmyPoints(armyMap.get(u.getTypeId()).pointValue)
