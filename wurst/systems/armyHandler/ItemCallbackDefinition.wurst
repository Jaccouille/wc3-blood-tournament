package ItemCallbackDefinition

import HashMap
import LinkedList
import LocalObjectIDs
import Assets
import OrderIds

public let itemAddUnitMap = new HashMap<int, ItemAddUnit>
public let itemModifyUnitMap = new HashMap<int, ItemModifyUnit>

interface AddUnitCallbackListener
    function execute(LinkedList<int> unitTospawn, int count)

interface ActionCallbackListener
    function execute(unit u)

public class ItemAddUnit
    private AddUnitCallbackListener listener

    function addAction(AddUnitCallbackListener listener)
        this.listener = listener

    function execute(LinkedList<int> unitTospawn, int count)
        this.listener.execute(unitTospawn, count)

public class ItemModifyUnit
    private ActionCallbackListener listener

    function addAction(ActionCallbackListener listener)
        this.listener = listener

    function execute(unit u)
        this.listener.execute(u)

function replaceUnit(LinkedList<int> unitToSpawn, int oldUnit, int newUnit)
    unitToSpawn.replace(oldUnit, newUnit)
    unitToSpawn.shuffle()

init
    let captainAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitTospawn, int count) ->
        for i = 0 to count
            unitTospawn.push(UNIT_ROYAL_GUARD)
    itemAddUnitMap.put(ITEM_CAPTAIN, captainAction)

    let crusaderAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            replaceUnit(unitToSpawn, UNIT_KNIGHT, UNIT_CRUSADER)

    let crusaderUnitAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.setScale(2.0)
    itemAddUnitMap.put(ITEM_CRUSADER, crusaderAction)
    itemModifyUnitMap.put(ITEM_CRUSADER, crusaderUnitAction)

    let rangerAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 0 to count
            unitToSpawn.push(UNIT_RANGER)
    itemAddUnitMap.put(ITEM_RANGER, rangerAction)

    let spellBreakerAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 0 to count
            unitToSpawn.push(UNIT_SPELL_BREAKER)
    itemAddUnitMap.put(ITEM_SPELL_BREAKER, spellBreakerAction)


    let innerFireAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_INNER_FIRE)
        u.issueImmediateOrderById(OrderIds.innerfireon)

    itemModifyUnitMap.put(ITEM_INNER_FIRE, innerFireAction)


    let darkMageAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_ORB_DARKNESS)

    itemModifyUnitMap.put(ITEM_DARK_MAGE, darkMageAction)


    let fireMageAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_INCINERATE)
        u.addAbility(ABIL_AUTOCAST_FIRE_SHIELD)
        u.issueImmediateOrderById(OrderIds.innerfireon)

    itemModifyUnitMap.put(ITEM_FIRE_MAGE, fireMageAction)


    let iceMageAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_ORB_FROST)
        u.addAbility(ABIL_FROST_ARMOR)
        u.issueImmediateOrderById(OrderIds.innerfireon)

    itemModifyUnitMap.put(ITEM_ICE_MAGE, iceMageAction)

    let spiritWolfAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 0 to count
            unitToSpawn.push(UNIT_SPIRIT_WOLF1)
    itemAddUnitMap.put(ITEM_SPIRIT_WOLF1, spiritWolfAction)


    let healingWaveAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_HEALING_WAVE)
        u.addAbility(ABIL_AUTOCAST_HEALING_WAVE)
        u.issueImmediateOrderById(OrderIds.innerfireon)

    itemModifyUnitMap.put(ITEM_HEALING_WAVE, healingWaveAction)

    let berserkerAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            replaceUnit(unitToSpawn, UNIT_GRUNT, UNIT_BERSERKER)
    itemAddUnitMap.put(ITEM_BERSERKER, berserkerAction)

    let packLeaderAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            unitToSpawn.push(UNIT_PACK_LEADER)
    itemAddUnitMap.put(ITEM_PACK_LEADER, packLeaderAction)

    let armoredOgreAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            replaceUnit(unitToSpawn, UNIT_OGRE, UNIT_OGRE_ARMORED)
    itemAddUnitMap.put(ITEM_OGRE_ARMORED, armoredOgreAction)


    let fireArrowAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            replaceUnit(unitToSpawn, UNIT_SKELETAL_ARCHER, UNIT_BURNING_ARCHER)
    itemAddUnitMap.put(ITEM_BURNING_ARCHER, fireArrowAction)

    let frostArrowAction = new ItemAddUnit()
        ..addAction() (LinkedList<int> unitToSpawn, int count) ->
        for i = 1 to count
            replaceUnit(unitToSpawn, UNIT_SKELETAL_ARCHER, UNIT_FROST_ARCHER)
    itemAddUnitMap.put(ITEM_FROST_ARCHER, frostArrowAction)

    let unholyFrenzyAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.removeAbility(ABIL_AUTOCAST_ANTI_MAGIC_SHELL)
        u.removeAbility(ABIL_ANTI_MAGIC_SHELL)
        u.addAbility(ABIL_AUTOCAST_UNHOLY_FRENZY)
        u.addAbility(ABIL_UNHOLY_FRENZY)
        u.issueImmediateOrderById(OrderIds.innerfireon)

    itemModifyUnitMap.put(ITEM_UNHOLY_FRENZY, unholyFrenzyAction)

    let raiseSkeletonMageAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.removeAbility(ABIL_RAISE_SKELETON)
        u.addAbility(ABIL_RAISE_SKELETON_MAGE)
        u.issueImmediateOrderById(OrderIds.raisedeadon)

    itemModifyUnitMap.put(ITEM_RAISE_SKELETON_MAGE, raiseSkeletonMageAction)

    let crippleAction = new ItemModifyUnit()
        ..addAction() (unit u) ->
        u.addAbility(ABIL_CRIPPLE_ORB)

    itemModifyUnitMap.put(ITEM_CRIPPLE, crippleAction)
