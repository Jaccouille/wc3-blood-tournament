package RoundController

// Standard libs imports:
import ClosureForGroups
import ClosureTimers
import TimerUtils

// Local imports:
import public Round
import AltarEntity

public constant roundController = new RoundController()

constant SPAWN_TIME = 5.

interface OnAllroundsFinished
    abstract function execute()

public OnAllroundsFinished onAllroundsFinished

class RoundController
    constant rounds = new LinkedList<Round>
    player previousRoundWinner = null

    Round currentRound = null

    function addRound(Round round)
        this.rounds.add(round)

    function addRounds(LinkedList<Round> rounds)
        this.rounds.addAll(rounds.copy())

    function roundSpawn()
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            u.pause()
        if rounds.isEmpty()
            onAllroundsFinished.execute()
            return

        let tim = getTimer()
        // TODO: cleanup
        // let tdialog = tim.createTimerDialog()
        // ..setTitle("Time until next round:")
        // ..display(true)
        tim.doAfter(SPAWN_TIME) ->
            // tdialog.destr()

            currentRound = rounds.dequeue()
            currentRound.start()

    function checkIfCurrentroundDone(player winner)
        if currentRound != null
            currentRound.finish(winner)
            if previousRoundWinner == null
                Log.info("Adding previous winner " + winner.getName())
                previousRoundWinner = winner
            else
                Log.info("Removing previous winner")
                previousRoundWinner = null
            currentRound = null
            roundSpawn()

function generateFinalMatchup() returns LinkedList<Pair<int, int>>
    Log.info("[RoundController] [generateFinalMatchup]")
    let matches = new LinkedList<Pair<int, int>>
    let playerList = asList(0, 1, 2, 3, 4, 5, 6, 7, 8)
    // var idx = 0

    // print(playerList.get(idx))
    for idx = 0 to playerList.size() - 2 step 2
        Log.info("loop")
        print(playerList.get(idx))
        print(playerList.get(idx + 1))
        matches.add(new Pair(playerList.get(idx), playerList.get(idx + 1)))
    // let iterator = playerList.iterator()
    // while iterator.hasNext()
    //     Log.info("loop")
    //     Log.info(iterator.next().toString())
    // iterator.close()

    // while idx < playerList.length()
    //     Log.info("i = " + idx.toString())
    //     Log.info(playerList.get(idx))
    //     Log.info(playerList.get(idx + 1))
    //     matches.add(new Pair(playerList.get(idx), playerList.get(idx + 1)))
    //     idx += 2
    return matches

function generateFinalRoundQuarterFinal()
    let matches = generateFinalMatchup()
    for matchUp in matches
        roundController.addRounds(asList<Round>(
            new FinalRound()
                ..addMatchup(matchUp)
            )
        )

function initRounds()
    roundController.addRounds(asList<Round>(
            // new NormalRound()
            //     ..setRewards(600, 0)
            //     ..addMatchup(new Pair(0, 1))
            //     ..addMatchup(new Pair(2, 3))
            //     ..addMatchup(new Pair(4, 5))
            //     ..addMatchup(new Pair(6, 7)),
            // new NormalRound()
            //     ..setRewards(600, 0)
            //     ..addMatchup(new Pair(0, 1))
            //     ..addMatchup(new Pair(2, 3))
            //     ..addMatchup(new Pair(4, 5))
            //     ..addMatchup(new Pair(6, 7)),
            // new NormalRound()
            //     ..setRewards(600, 0)
            //     ..addMatchup(new Pair(0, 1))
            //     ..addMatchup(new Pair(2, 3))
            //     ..addMatchup(new Pair(4, 5))
            //     ..addMatchup(new Pair(6, 7)),
            // new NormalRound()
            //     ..setRewards(600, 0)
            //     ..addMatchup(new Pair(0, 1))
            //     ..addMatchup(new Pair(2, 3))
            //     ..addMatchup(new Pair(4, 5))
            //     ..addMatchup(new Pair(6, 7))
        ))

public function initRoundController()
    initRounds()
    generateFinalRoundQuarterFinal()

    doAfter(2) ->
        roundController.roundSpawn()

    onRoundFinish() (Round round) ->
        Log.info(round.roundName + " finished")
        if roundController.currentRound instanceof FinalRound
            if roundController.previousRoundWinner != null
                Log.info("Adding " + roundController.previousRoundWinner.getNameColored(true) + " vs " + round.winner.getNameColored(true))
                roundController.addRound(
                    new FinalRound()
                        ..addMatchup(new Pair(roundController.previousRoundWinner.getId(), round.winner.getId())))

        doAfter(3) ->
            altarEntity.hideCounter()
            let winner = round.winner
            printTimed(winner.getName() + " gets " + altarEntity.bloodPointCounter.toString() + " for winning the round" , 15)
            forUnitsAll() (unit u) ->
                if IsUnitDeadBJ(u)
                    u.remove()
        doAfter(5) ->
            if round.goldReward > 0
                printTimed("You get " + round.goldReward.toString() + " golds from round income", 15)
            if round.bloodPointReward > 0
                printTimed("You get " + round.bloodPointReward.toString() + " blood points from round income", 15)
            pDatas.forEach() (player key, PlayerData value) ->
                value.giveReward()
                key.addGold(round.goldReward)
                key.addLumber(round.bloodPointReward)

    onLastArmyRemaining = () ->
        forUnitsOfPlayer(ALTAR_PLAYER) (unit u) ->
            u.unpause()
        Log.info("Clean up phase")
        altarEntity.showCounter()

    onAllUnitDead = (player winner) ->
        Log.info("All unit dead")
        roundController.checkIfCurrentroundDone(winner)

    onAllroundsFinished = () ->
        Log.info("Match over")
        if roundController.previousRoundWinner != null
            print(roundController.previousRoundWinner.getName() + " is the Blood tournament champion!")


// TODO: Move else where
public function initUnitDeathTrigger()
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
    ..addCondition(Condition(() -> GetDyingUnit().getPointValue() > 0))
    ..addAction() ->
        let killer = EventData.getKillingUnit().getOwner()
        let dying = EventData.getDyingUnit()

        let dyingOwner = dying.getOwner()

        let pData = pDatas.get(dying.getOwner())
        // Add blood points bounty
        if killer != ALTAR_PLAYER
            pDatas.get(killer).addBounty(dying.getPointValue())
            createTTEx(
                dying.getPos3Real(),
                "+" + dying.getPointValue().toString(),
                8,
                colorA(255, 0, 0, 255),
                killer
            )
            ..setVelocity(0.0, 0.03)
            ..setFadepoint(1.5)
            ..setLifespan(2.0)
            ..setPermanent(false)

        if pData.spawnedUnits.has(dying) == true
            pData.spawnedUnits.remove(dying)

        if pData.spawnedUnits.isEmpty()
            roundController.currentRound.roundParticipant.remove(dyingOwner)

            Log.info("Removed " + dyingOwner.getName())

            if roundController.currentRound.roundParticipant.size() == 1
                onLastArmyRemaining.execute()
            if roundController.currentRound.roundParticipant.isEmpty()
                onAllUnitDead.execute(dyingOwner)
